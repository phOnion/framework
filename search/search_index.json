{
    "docs": [
        {
            "location": "/",
            "text": "About\n\n\nThis is a minimalistic core framework that complies with, supports and uses various\nPSRs:\n\n\n\n\nPSR-2 (Coding Standard)\n\n\nPSR-4 (Autoloading)\n\n\nPSR-7 (HTTP Message)\n\n\nPSR-11 (Container Interface)\n\n\nPSR-15 (HTTP Middleware)\n\n\nPSR-16 (Simple Caching) - \ncontainer wrapper only\n\n\n\n\nWhile it can be used to power a full-blown application framework as of now\nit is mainly oriented towards the core tools needed for building an API.\nBeing maily API oriented, now there is a package \nonion/rest\n that provides\na few classes that should simplify the generation of API-standard responses\nas well as \nonion/interfaces\n's \nOnion\\Framework\\Rest\n namespace has a couple\nof interfaces aimed specifically at that.\n\n\nIn the latest release a lot of changes have been made, to note a few major ones\n\n\n\n\nPHP >= 7.2 is the minimal version required\n\n\nMany components that might increase the loading times have been made 'lazy' with the help of generators\n\n\nThere is no router! Everything is oriented towards true middleware architecture, so middleware and request handlers are used heavily\n\n\nRoute's now can be initialized using a custom classes instead of the old approach with matchers/parsers\n\n\nModularity is now possible through combination of appropriate PrefixRoutes and Application (no more delegate classes)\n\n\n\n\nContent Negotiation is something that is planned but since it is not so trivial task, it is postponed for future minor release\n\n\nRequirements\n\n\n\n\nPHP 7.2+\n\n\nphp.ini (Optional but recommended while development)\n\n\nzend.assertions=1\n\n\nassert.exceptions=1\n\n\n\n\n\n\n\n\nThe php.ini configuration is suggested only while development, so that some errors, which\ncould happen only while developing (misspelled array key, invalid configuration, etc.) are\nnot checked all the time while running on production environment - squeezing as much\nperformance as possible.\n\n\nFor a quick start you can clone \nonion/bootstrap\n and\nsee how the basic setup looks like and play around to test the features available.\n\n\nConfiguration\n\n\nThe approach taken for setting up the framework is more configuration over convention\nbecause everyone has different code-style and different tastes, there is no point in\nenforcing a specific way to code something so that it works, without providing any\nother way. So there are some configurations for some components and they are explained\nin their respectful sections of this documentation.",
            "title": "Intro"
        },
        {
            "location": "/#about",
            "text": "This is a minimalistic core framework that complies with, supports and uses various\nPSRs:   PSR-2 (Coding Standard)  PSR-4 (Autoloading)  PSR-7 (HTTP Message)  PSR-11 (Container Interface)  PSR-15 (HTTP Middleware)  PSR-16 (Simple Caching) -  container wrapper only   While it can be used to power a full-blown application framework as of now\nit is mainly oriented towards the core tools needed for building an API.\nBeing maily API oriented, now there is a package  onion/rest  that provides\na few classes that should simplify the generation of API-standard responses\nas well as  onion/interfaces 's  Onion\\Framework\\Rest  namespace has a couple\nof interfaces aimed specifically at that.  In the latest release a lot of changes have been made, to note a few major ones   PHP >= 7.2 is the minimal version required  Many components that might increase the loading times have been made 'lazy' with the help of generators  There is no router! Everything is oriented towards true middleware architecture, so middleware and request handlers are used heavily  Route's now can be initialized using a custom classes instead of the old approach with matchers/parsers  Modularity is now possible through combination of appropriate PrefixRoutes and Application (no more delegate classes)   Content Negotiation is something that is planned but since it is not so trivial task, it is postponed for future minor release",
            "title": "About"
        },
        {
            "location": "/#requirements",
            "text": "PHP 7.2+  php.ini (Optional but recommended while development)  zend.assertions=1  assert.exceptions=1     The php.ini configuration is suggested only while development, so that some errors, which\ncould happen only while developing (misspelled array key, invalid configuration, etc.) are\nnot checked all the time while running on production environment - squeezing as much\nperformance as possible.  For a quick start you can clone  onion/bootstrap  and\nsee how the basic setup looks like and play around to test the features available.",
            "title": "Requirements"
        },
        {
            "location": "/#configuration",
            "text": "The approach taken for setting up the framework is more configuration over convention\nbecause everyone has different code-style and different tastes, there is no point in\nenforcing a specific way to code something so that it works, without providing any\nother way. So there are some configurations for some components and they are explained\nin their respectful sections of this documentation.",
            "title": "Configuration"
        },
        {
            "location": "/setup/",
            "text": "Introduction\n\n\nIn this section we'll get through a simple hello world app to help you\nget a grip around the concepts of the framework as well as how to\nset it up and work on it.\n\n\n1st thing is the index file, it is the entry point for the application.\nThe application consists of middleware, which if you are not familiar\nwith you should think of as onion's layers (now you get where the name\ncomes from). See:\n\n\n\n\n\n\nPSR-15 Specification\n\n\n\n\n\n\nWhy Care About PHP Middleware?\n by \nPhil Phil Sturgeon\n\n\n\n\n\n\nChoosing single pass ensures no funny business will be going inside the\nmiddleware you use, and you can be sure that the response you return\nwill be consistently handled, and you will not have to keep track of\nthe double-pass response object, that may or may not have some specific\nheaders set by any of the middleware called before your \"controller\".\n\n\nInstallation\n\n\nSo with that being said, lets jump right in with the installation\nand setup of the \"hello world\" project:\n\n\n\n\ncomposer require onion/framework:2.0\n\n\nCreate the public directory one that will be exposed by the web server, referred to as \npublic\n in this example\n\n\nIn it, create a file named \nindex.php\n and inside of it paste the code below.\n\n\nTo test it after you copied and pasted the code run the following:\n \nphp -S localhost:12345 -t public/\n inside the projects directory,\n that will start the PHP built-in server and will make the application\n  code accessible on: \nlocalhost:12345\n\n\n\n\n    <?php\n    declare(strict_types=1);\n    require_once __DIR__ . '/../vendor/autoload.php';\n    use Onion\\Framework;\n\n    $container = new Framework\\Dependency\\Container((object) [\n        'factories' => (object) [\n            Framework\\Application\\Application::class => // Takes care of routing\n                Framework\\Application\\Factory\\ApplicationFactory::class,\n            \\Psr\\Http\\Server\\RequestHandlerInterface::class => // Necessary for error handling\n                Framework\\Http\\Middleware\\Factory\\RequestHandlerFactory::class\n        ],\n        'invokables' => (object) [\n            // Optional, this is the default behavior,\n            // change if a different response template should be used\n            \\Psr\\Http\\Message\\ResponseInterface::class =>\n                \\Guzzle\\Psr7\\Response::class\n        ],\n        'routes' => [ // Application routes\n            [ // A route :D\n                'pattern' => '/',\n                'middleware' => [\n                    // Add your route middleware here\n                ]\n            ]\n        ],\n        'middleware' => [\n            // Application-level middleware should go here\n        ]\n    ]);\n\n    $app = $container->get(Framework\\Application\\Application::class);\n    $app->run(GuzzleHttp\\Psr7\\ServerRequest::fromGlobals()); // Or another request factory\n\n\n\n\nNote You need to implement your route middleware and define it here otherwise an empty response will be returned\n\n\nAfter accessing the app you should be presented with whatever output you expect to see. That is it\n\n\n\n\nRouting\n\n\nPlease refer to the routes section for more information about the specifics\nof a route.\n\n\nMiddleware\n\n\nThere are 2 types of middleware supported atm, application level & route level.\nCurrently the handling of application level middleware is achieved in 2 ways\n\n\n\n\nIf a route is triggered the application middleware is \"attached\" infront of\n the route middleware and the execution happens transparently for the route and\n the prepend logic is located inside the \nApplicationFactory\n so if another\n factory is used to build the route stack, that should be taken in to account.\n\n\nIf there is an exception (which is what happens when no route is found as well\n as from the application code) a generic \nRequestHandler\n is built with only\n the global middleware and the thrown exception is added to the request attributes\n as \nerror\n and \nexception\n.\n\n\n\n\nIn an ideal scenario that should not be a huge issue when route error occurs\n and the common stack is triggered again, although it should be taken in to\n account for the purposes of request logging, etc. as it may result in duplicate\n entries for the same request. (But you really should handle your errors :) )",
            "title": "Tutorial"
        },
        {
            "location": "/setup/#introduction",
            "text": "In this section we'll get through a simple hello world app to help you\nget a grip around the concepts of the framework as well as how to\nset it up and work on it.  1st thing is the index file, it is the entry point for the application.\nThe application consists of middleware, which if you are not familiar\nwith you should think of as onion's layers (now you get where the name\ncomes from). See:    PSR-15 Specification    Why Care About PHP Middleware?  by  Phil Phil Sturgeon    Choosing single pass ensures no funny business will be going inside the\nmiddleware you use, and you can be sure that the response you return\nwill be consistently handled, and you will not have to keep track of\nthe double-pass response object, that may or may not have some specific\nheaders set by any of the middleware called before your \"controller\".",
            "title": "Introduction"
        },
        {
            "location": "/setup/#installation",
            "text": "So with that being said, lets jump right in with the installation\nand setup of the \"hello world\" project:   composer require onion/framework:2.0  Create the public directory one that will be exposed by the web server, referred to as  public  in this example  In it, create a file named  index.php  and inside of it paste the code below.  To test it after you copied and pasted the code run the following:\n  php -S localhost:12345 -t public/  inside the projects directory,\n that will start the PHP built-in server and will make the application\n  code accessible on:  localhost:12345       <?php\n    declare(strict_types=1);\n    require_once __DIR__ . '/../vendor/autoload.php';\n    use Onion\\Framework;\n\n    $container = new Framework\\Dependency\\Container((object) [\n        'factories' => (object) [\n            Framework\\Application\\Application::class => // Takes care of routing\n                Framework\\Application\\Factory\\ApplicationFactory::class,\n            \\Psr\\Http\\Server\\RequestHandlerInterface::class => // Necessary for error handling\n                Framework\\Http\\Middleware\\Factory\\RequestHandlerFactory::class\n        ],\n        'invokables' => (object) [\n            // Optional, this is the default behavior,\n            // change if a different response template should be used\n            \\Psr\\Http\\Message\\ResponseInterface::class =>\n                \\Guzzle\\Psr7\\Response::class\n        ],\n        'routes' => [ // Application routes\n            [ // A route :D\n                'pattern' => '/',\n                'middleware' => [\n                    // Add your route middleware here\n                ]\n            ]\n        ],\n        'middleware' => [\n            // Application-level middleware should go here\n        ]\n    ]);\n\n    $app = $container->get(Framework\\Application\\Application::class);\n    $app->run(GuzzleHttp\\Psr7\\ServerRequest::fromGlobals()); // Or another request factory  Note You need to implement your route middleware and define it here otherwise an empty response will be returned  After accessing the app you should be presented with whatever output you expect to see. That is it",
            "title": "Installation"
        },
        {
            "location": "/setup/#routing",
            "text": "Please refer to the routes section for more information about the specifics\nof a route.",
            "title": "Routing"
        },
        {
            "location": "/setup/#middleware",
            "text": "There are 2 types of middleware supported atm, application level & route level.\nCurrently the handling of application level middleware is achieved in 2 ways   If a route is triggered the application middleware is \"attached\" infront of\n the route middleware and the execution happens transparently for the route and\n the prepend logic is located inside the  ApplicationFactory  so if another\n factory is used to build the route stack, that should be taken in to account.  If there is an exception (which is what happens when no route is found as well\n as from the application code) a generic  RequestHandler  is built with only\n the global middleware and the thrown exception is added to the request attributes\n as  error  and  exception .   In an ideal scenario that should not be a huge issue when route error occurs\n and the common stack is triggered again, although it should be taken in to\n account for the purposes of request logging, etc. as it may result in duplicate\n entries for the same request. (But you really should handle your errors :) )",
            "title": "Middleware"
        },
        {
            "location": "/dependency/",
            "text": "The app comes with a very capable DI container, that provides the essential\nfunctionality to get an app running with as little issues as possible. It is\npretty similar to the one provided from ZF, but with some features omitted.\nThe container's dependencies are passed as an array in it's constructor and\nhave 3 special keys: \ninvokables\n, \nfactories\n and \nshared\n\n\nEverything outside of these 3 keys is treated just as a value and can be retrieved by calling\n\nContainer::get('someKey')\n and that will return the value of 'someKey' as-is, without performing\nany operations on it. Also if you need to access a specific key which is located in a nested\narray you can use a dot notation, which the container will interpret as indication for a level\nof the array. Say for example, you have an array:\n\n\nreturn [\n    'doctrine' =>  [\n        'connection' =>  [\n            'dbname' => 'foo',\n        ],\n    ],\n]\n\n\n\n\nOR\n\n\nreturn [\n    'doctrine' => [\n        'connection' => [\n            'dbname' => 'foo',\n            // ...\n        ]\n    ]\n]\n\n\n\n\nIn order to access \n'dbname'\n, you might have to do at least 2 ifs (to ensure the key is there) or\ndefinitely will have to make something like: \nContainer::get('doctrine')['connection']['dbname'] ?? false\n\nand then check if the key is equal to null, but that definetely is not the prettiest... This is where\nthis could come in to play, instead of doing that you can just do \nContainer::get('doctrine.connection.dbname');\n\nwhich will return \n'foo'\n or throw \nUnknownDependency\n if nothing is found and you are all set, and it looks\nclearer too + on thje bonus side if you are writing a distributable module, you can be sure that the\ncontainer will throw the appropriate error if any key is not defined and notify the user, no more\npiles of \nif\ns in your factories :)",
            "title": "Introduction"
        },
        {
            "location": "/dependency/invokables/",
            "text": "invokables\n are mappings from type to implementation, this is mainly intended\n for cases where a class binds to an interface and when the container needs to inject\n a blank instance of a given class. This will not perform any operations on the instance\n so it is expected those to be instances without a constructor or with a constructor that\n does not need any arguments. Consider it as a mapping between \ninterface => implementation\n\n\nA good practice is to use \n\\Acme\\App\\SomeClass::class\n instead of \n'someclass'\n as keys so\nit allows for auto-wiring and makes the code more obvious, more readable and lowers the\nchance of making typos as most editors will suggest the class proper class name.\n\n\nFor example:\n\n\nreturn  [\n    'invokables' =>  [\n         \\Psr\\Http\\Message\\ResponseInterface::class =>\n                \\Guzzle\\Psr7\\Response::class\n    ]\n];\n\n\n\n\nThis will create a mapping that will return a new instance of \n\\Guzzle\\Psr7\\Response\n whenever\n\n$container->get(\\Psr\\Http\\Message\\ResponseInterface::class);\n is used, also will allow automatic\ninjection to classes that do not have factories but have type-hints in their constructor, which\ncan tremendously reduce the amount of definitions that need to be defined manually if classes\nare defined with that in mind. A big use case for this could be when you define only the interface\nimplementations and instead of defining a factory for each class, you can type-hint against the\ninterface and do a \n$container->get(MyAwesomeClass::class)\n and boom all dependencies will be\ninjected automatically without sacrificing anything, not changing anything in the code.\n\n\nAlso, if the type-hint does not point to a object, but is a scalar the container will try to look\nfor definitions with the same name as the name of the variable, allowing a constructor with paramteres\n\n$fooBar\n to be resolved to the value of the \nfoo.bar\n using dot-notation for levels.\n\n\nBe careful tho as to not get in to a situation in which the wrong variables are injected. This\nis intended for very small and/or simple applications, for those that might grow it is advisable\nto stick to explicitly defined factories as to not fight mysterious bugs that don't make a lot of sense.",
            "title": "Invokables"
        },
        {
            "location": "/dependency/factories/",
            "text": "Basic factories\n\n\nfactories\n are another essential part of the container. These are manually created classes that\nimplement \n\\Onion\\Framework\\Dependency\\Interfaces\\FactoryInterface\n and serve as \"formulas\" how\nto build the dependency.\n\n\nFor example:\n\n\nreturn  [\n    'factories' =>  [\n         Framework\\Application\\Application::class =>\n                Framework\\Application\\Factory\\ApplicationFactory::class,\n    ]\n];\n\n\n\n\nThis tells the container, whenever \nRouterInterface\n is requested, to invoke the \nRouterFactory\n\nwhich returns an instance of the interface. This is the flexibility point of the container (not an\nexclusive feature but still) since it allows you to define manually the way an object instance is\nbuild and also provides an abstraction between the container's resolution and implementation details.\nIf you use setter injection you will have to use factories, as the container does not provide any\nway to auto-wire them. Also setter injected dependencies, could be considered optional and may not\nbe needed for the class, no need to spend time on them.\n\n\n\n\nAbstract factories\n\n\nAbstract factories are aimed to allow the creation of a factory for more\nthan can determine based on the key what object to return. In general it\nis a factory factory as it must return a \nFactoryInterface\n which will\nreturn the real object to be injected. For example if an abstract factory\nis used to build a cache service an \"alias\" key can be used like:\n\n\n// ...\n    'factories' => [\n        'cache:redis' => AbstractCacheFactory::class,\n    ],\n// ...\n\n\n\n\nThere the abstract factory can switch from which configuration to use\nwithout the need of defining factory for each option.\n\n\nThis could come in handy when dealing with multiple database, cache or\nother such backends or multiple servers, where the difference can be\nvery small (even a single string, like the \ndriver\n key in db configs).\n\n\nAbstract factory is defined under the \nfactories\n key, with the only\njust like with any other factory and all is handled transparently for\nthe application.\n\n\n\n\nMemory caching\n\n\nAnd if an object is often required, but does not need to be instantiated multiple times,\nthere is the \nshared\n key. It allows you to define the a list of factory keys that should not\nbe triggered on every request to the container, but actually \"share\" the same instance\nof the first result. This can be useful in scenarios like, constructing database connection,\ninstantiating connection to a remote service, etc. The main intent for this is to be used\nfor heavy objects which might be required on multiple places but sharing the same instance\nmakes sense.",
            "title": "Factories"
        },
        {
            "location": "/dependency/factories/#basic-factories",
            "text": "factories  are another essential part of the container. These are manually created classes that\nimplement  \\Onion\\Framework\\Dependency\\Interfaces\\FactoryInterface  and serve as \"formulas\" how\nto build the dependency.  For example:  return  [\n    'factories' =>  [\n         Framework\\Application\\Application::class =>\n                Framework\\Application\\Factory\\ApplicationFactory::class,\n    ]\n];  This tells the container, whenever  RouterInterface  is requested, to invoke the  RouterFactory \nwhich returns an instance of the interface. This is the flexibility point of the container (not an\nexclusive feature but still) since it allows you to define manually the way an object instance is\nbuild and also provides an abstraction between the container's resolution and implementation details.\nIf you use setter injection you will have to use factories, as the container does not provide any\nway to auto-wire them. Also setter injected dependencies, could be considered optional and may not\nbe needed for the class, no need to spend time on them.",
            "title": "Basic factories"
        },
        {
            "location": "/dependency/factories/#abstract-factories",
            "text": "Abstract factories are aimed to allow the creation of a factory for more\nthan can determine based on the key what object to return. In general it\nis a factory factory as it must return a  FactoryInterface  which will\nreturn the real object to be injected. For example if an abstract factory\nis used to build a cache service an \"alias\" key can be used like:  // ...\n    'factories' => [\n        'cache:redis' => AbstractCacheFactory::class,\n    ],\n// ...  There the abstract factory can switch from which configuration to use\nwithout the need of defining factory for each option.  This could come in handy when dealing with multiple database, cache or\nother such backends or multiple servers, where the difference can be\nvery small (even a single string, like the  driver  key in db configs).  Abstract factory is defined under the  factories  key, with the only\njust like with any other factory and all is handled transparently for\nthe application.",
            "title": "Abstract factories"
        },
        {
            "location": "/dependency/factories/#memory-caching",
            "text": "And if an object is often required, but does not need to be instantiated multiple times,\nthere is the  shared  key. It allows you to define the a list of factory keys that should not\nbe triggered on every request to the container, but actually \"share\" the same instance\nof the first result. This can be useful in scenarios like, constructing database connection,\ninstantiating connection to a remote service, etc. The main intent for this is to be used\nfor heavy objects which might be required on multiple places but sharing the same instance\nmakes sense.",
            "title": "Memory caching"
        },
        {
            "location": "/dependency/shared/",
            "text": "There is also the root \n'shared'\n meta-key that indicates to the container\nwhich resolutions should be cached and return the same instance on every\nconsequent request made to the container. A good example for this would be\nthe \n\\PDO\n or other object that upon instantiation opens a connection to\nanother remote service. It is supported for both \ninvokable\n and \nfactories\n\nentries. In those cases you might do something like:\n\n\nreturn  [\n    'database' =>  [\n        'driver' => 'mysqli',\n        'database' => __DIR__ . '/some.db',\n    ],\n    'factories' => [\n        \\PDO::class => \\My\\Pdo\\Factory::class,\n    ],\n    'shared' => [\n        \\PDO::class,\n    ],\n];\n\n\n\n\nWhat this will do is upon the first request the PDO object will be created\nand if it resolves without any problems the same instance will be used\nwhenever you request \n\\PDO::class\n avoiding opening of multiple connections\nfor every class that is resolved through auto-wiring or requiering always to\nkeep track of a global connection pool or any other complex technique that\nwill almost certainly be out of the scope of what you are trying to do (\nExcept if you are building an ORM, which you shouldn't unless you have a\nreally good reason to do so, but srsly... please dont <3 ).",
            "title": "In-memory Caching"
        },
        {
            "location": "/dependency/caching/",
            "text": "When applications are running on production it is safe to assume that DI containers\ncan make relatively heavy use of caching so they can squeeze the maximum\nperformance. This is should not be any different. And to make this possible\nit is not necessary to come up with your own solution. A caching (delegate)container\ncomes bundled inside the framework - \nOnion\\Framework\\Dependency\\CacheAwareContainer\n.\nIn order to utilize it you just have to define a container factory (a class\nimplementing the \nFactoryInterface\n) and pass it as the first argument to the\ncache-aware container, pass an instance of \nPsr\\SimpleCache\\CacheInterface\n\nas the second one and you are ready to go.\n\n\nBy default that container will cache every dependency that it retrieves, but\nif you have a factory that, for example checks for results in the database and\nuses information from there to build the dependency on a per-user basis you\nmight not want to cache that result, here comes the third argument of the\ncontainer - blacklist. It allows you to specify a list of keys that should\nnot be cached and should always be retrieved from the delegated container.",
            "title": "Persistent Caching"
        },
        {
            "location": "/dependency/delegation/",
            "text": "Container delegation is part of the spec but there are not any specifics\non how the interface should look like, so for the purpose of not to do voodoo\nthere is the \nAttachableContainer\n interface, that the child containers\nneed to implement in order to allow injecting of the parent container inside.\n\n\nThis might not seem to be the prettiest solution but will allow for\nsome way to pass the delegate container to the child and preserve the\nrequired way of working with the container validation:\n\n\nSee this document for more information about Container Delegation\n\n\nAfter some changes in the way how the delegate container works, now it is\npossible to return aggregated configuration. Say for example if there are\ntwo containers that define 'list.foo', but with different values, like:\n\n\n$c1 = new Container([\n    'foo' => [\n        'list' => [\n            'bar' => 'baz',\n        ],\n    ],\n]);\n\n// And\n\n$c2 = new Container([\n    'foo' => [\n        'list' => [\n            'baz' => 'foo',\n        ],\n    ],\n]);\n\n// when retrieving from a delegate\n\n$delegateContainer->get('foo.list'); // returns ['bar' => 'baz', 'baz' => 'foo']\n\n\n\n\nThis is alternative approach to the old behavior where only the first result\nwill be returned. This allows for greater flexibility like having \nroutes\n\ndefined in many containers to be retrieved and instantiated through the same\ncontainer. Which comes especially useful when it comes to modules.",
            "title": "Delegation"
        },
        {
            "location": "/routing/",
            "text": "Introduction\n\n\nSince the \nRouter\n class has been removed in the 2.0 release the concept of routing\nhas been moved to the application class + the dispatching has been moved inside the\nRoute classes hance making them self-contained and responsible for their own execution.\n\n\nThus the \nApplication\n class has absolutely no knowledge of how the route is dispatched\nit just \"asks\" it if it matches the current request and if it is - handles the sending\nof the response to the client.\n\n\nThe route definition structure has not changed much:\n\n\nreturn [\n    'routes' => [\n        [\n            'name' => 'home', // Optional\n            'pattern' => '/', // Required. Not changed at all\n            'methods' => [], // Optional\n            'class' => \\Onion\\Framework\\Router\\StaticRoute::class, // New! Optional, what class to use when building the route\n            'headers' => [ // NEW! Optional, a list of headers to enforce to the route's request\n                'x-random-stuff' => true,\n                'x-more-random-stuff' => false,\n            ],\n            'request_handler' => 'RequestHandlerKey', // NEW! Optional, instance to directly attach to the route\n            'middleware' => [] // Required. List of keys for the middleware of the route, omitted if `request_handler` is present\n        ]\n    ]\n];\n\n\n\n\nIf a custom \nclass\n is provided, it will be used for managing the route. That way a custom dispatch strategy could be used\nand/or changes of pattern syntax and what not. As for \nheaders\n it is intended to validate required headers to a response of the route\non success. Things like explicitly setting HTTP Cache value for example can be added here and remove the need for adding\ndata to the logic or implement some sort of a redirect route.\n\n\nDefinition\n\n\nThe full route structure looks like this:\n\n\n[\n    'name' => 'alias-name', // Optional\n    'pattern' => '/products/{product}', // Required\n    'class' => SomeRoute::class, // Optional\n    'request_handler' => SomeRequestHandler::class, // Optional\n    'middleware' => [ // Required, if `request_handler` is not present\n        // list of middleware keys to resolve\n    ],\n    'methods' => [ // Optional\n        // list of HTTP methods\n    ],\n    'headers' => [ // Optional\n        'x-header-name' => true // Definition of a route header\n    ]\n]\n\n\n\n\n\n\n'name'\n - An alias for a route useful if resolving pattern to route\n\n\n'pattern'\n - The pattern of the route\n\n\n'request_handler'\n - A request handler to use, bypassing the use of middleware (Useful for modules)\n\n\n'middleware'\n - A list of middleware keys that handle the route. Ignored if \nrequest_handler\n is present\n\n\n'class'\n - A class which will handle the route (Defaults to \nRegexRoute\n)\n\n\n'methods'\n - A list of HTTP methods to restrict the route to. Useful for early termination\n\n\n'headers'\n - A list of headers to enforce in the request and mark them as required or not.\n\n\n\n\nRoute headers could be handy when needing to enforce a rule on a given route.\nFor example require the requests to provide an \nAuthorization\n header will\nhave \n'Authorization' => true\n enforcing it and if it is not provided non of the\nmiddleware stack will be triggered and the app will return early. Making you\nnot have to check if the header is present all over the place. This can be of a\nhuge benefit if a module is entirely user protected to restrict access to it.\n\n\nRoute types\n\n\n1. \nStaticRoute\n\n\nHandles the request path as is, without doing anything behind the scenes and triggers it's stack directly.\n\n\n2. \nRegexRoute\n\n\nThis route is the default one used by the default application factory.\nAs the name implies it is a regex-based routing that supports optional\nparameters and parameter validation in it's syntax. To access route\nparameters you must use \n$request->getAttribute('parameterName');\n from\nthe incoming request.\n\n\nPattern Syntax\n\n\nIn order to define a parameter you must surround the \"key\" with square\nbraces \n{parameter}\n and in the common scenario you are done. For example the\nfollowing pattern has a parameter named \nid\n, which is required: \n/products/{id}\n.\n\n\nOptional Params\n\n\nOptional parameters use the same syntax, you just have to add question makr\n\n?\n ath end of the param and you are good, like \n{parameter}?\n.\nUpdating the same example as before with making the \nid\n parameter optional:\n\n/product/{id}?\n. Note that the \n/\n is before the parameter name and that will\nmake it required. If you want to avoid having that, you can surround your parameter\npart of an optional group by doing this: \n/product{/{id}}?\n this will\nindicate that the trailing slash is required only when the has a value\nfor \n{id}\n provided.\n\n\nParameter Constraints\n\n\nIn order to put constraints on a route we can use \n:\n after the parameter\nname to denote that what is after it and before the \n}\n is a pattern.\nFor example to enforce our \n{id}\n parameter from above to accept only integers\nwe can define it as such: \n/product{/{id:\\d+}}?\n that way if it is present\nit will have to be of 1+ numeric characters.",
            "title": "Introduction"
        },
        {
            "location": "/routing/#introduction",
            "text": "Since the  Router  class has been removed in the 2.0 release the concept of routing\nhas been moved to the application class + the dispatching has been moved inside the\nRoute classes hance making them self-contained and responsible for their own execution.  Thus the  Application  class has absolutely no knowledge of how the route is dispatched\nit just \"asks\" it if it matches the current request and if it is - handles the sending\nof the response to the client.  The route definition structure has not changed much:  return [\n    'routes' => [\n        [\n            'name' => 'home', // Optional\n            'pattern' => '/', // Required. Not changed at all\n            'methods' => [], // Optional\n            'class' => \\Onion\\Framework\\Router\\StaticRoute::class, // New! Optional, what class to use when building the route\n            'headers' => [ // NEW! Optional, a list of headers to enforce to the route's request\n                'x-random-stuff' => true,\n                'x-more-random-stuff' => false,\n            ],\n            'request_handler' => 'RequestHandlerKey', // NEW! Optional, instance to directly attach to the route\n            'middleware' => [] // Required. List of keys for the middleware of the route, omitted if `request_handler` is present\n        ]\n    ]\n];  If a custom  class  is provided, it will be used for managing the route. That way a custom dispatch strategy could be used\nand/or changes of pattern syntax and what not. As for  headers  it is intended to validate required headers to a response of the route\non success. Things like explicitly setting HTTP Cache value for example can be added here and remove the need for adding\ndata to the logic or implement some sort of a redirect route.",
            "title": "Introduction"
        },
        {
            "location": "/routing/#definition",
            "text": "The full route structure looks like this:  [\n    'name' => 'alias-name', // Optional\n    'pattern' => '/products/{product}', // Required\n    'class' => SomeRoute::class, // Optional\n    'request_handler' => SomeRequestHandler::class, // Optional\n    'middleware' => [ // Required, if `request_handler` is not present\n        // list of middleware keys to resolve\n    ],\n    'methods' => [ // Optional\n        // list of HTTP methods\n    ],\n    'headers' => [ // Optional\n        'x-header-name' => true // Definition of a route header\n    ]\n]   'name'  - An alias for a route useful if resolving pattern to route  'pattern'  - The pattern of the route  'request_handler'  - A request handler to use, bypassing the use of middleware (Useful for modules)  'middleware'  - A list of middleware keys that handle the route. Ignored if  request_handler  is present  'class'  - A class which will handle the route (Defaults to  RegexRoute )  'methods'  - A list of HTTP methods to restrict the route to. Useful for early termination  'headers'  - A list of headers to enforce in the request and mark them as required or not.   Route headers could be handy when needing to enforce a rule on a given route.\nFor example require the requests to provide an  Authorization  header will\nhave  'Authorization' => true  enforcing it and if it is not provided non of the\nmiddleware stack will be triggered and the app will return early. Making you\nnot have to check if the header is present all over the place. This can be of a\nhuge benefit if a module is entirely user protected to restrict access to it.",
            "title": "Definition"
        },
        {
            "location": "/routing/#route-types",
            "text": "",
            "title": "Route types"
        },
        {
            "location": "/routing/#1-staticroute",
            "text": "Handles the request path as is, without doing anything behind the scenes and triggers it's stack directly.",
            "title": "1. StaticRoute"
        },
        {
            "location": "/routing/#2-regexroute",
            "text": "This route is the default one used by the default application factory.\nAs the name implies it is a regex-based routing that supports optional\nparameters and parameter validation in it's syntax. To access route\nparameters you must use  $request->getAttribute('parameterName');  from\nthe incoming request.",
            "title": "2. RegexRoute"
        },
        {
            "location": "/routing/#pattern-syntax",
            "text": "In order to define a parameter you must surround the \"key\" with square\nbraces  {parameter}  and in the common scenario you are done. For example the\nfollowing pattern has a parameter named  id , which is required:  /products/{id} .",
            "title": "Pattern Syntax"
        },
        {
            "location": "/routing/#optional-params",
            "text": "Optional parameters use the same syntax, you just have to add question makr ?  ath end of the param and you are good, like  {parameter}? .\nUpdating the same example as before with making the  id  parameter optional: /product/{id}? . Note that the  /  is before the parameter name and that will\nmake it required. If you want to avoid having that, you can surround your parameter\npart of an optional group by doing this:  /product{/{id}}?  this will\nindicate that the trailing slash is required only when the has a value\nfor  {id}  provided.",
            "title": "Optional Params"
        },
        {
            "location": "/routing/#parameter-constraints",
            "text": "In order to put constraints on a route we can use  :  after the parameter\nname to denote that what is after it and before the  }  is a pattern.\nFor example to enforce our  {id}  parameter from above to accept only integers\nwe can define it as such:  /product{/{id:\\d+}}?  that way if it is present\nit will have to be of 1+ numeric characters.",
            "title": "Parameter Constraints"
        },
        {
            "location": "/hydratable/",
            "text": "The hydratables are traits which provide you the ability to \"inject\" data within objects that are initialized, but please note that those preserve the class' immutability and as such return new instance on every hydration. While there is an interface defining the \nhydrate\n and \nextract\n methods, there are 2 traits providing the 2 most common strategies for hydration:\n\n\n\n\nMethod\n - uses getters/setters\n\n\nProperty\n - uses public properties\n\n\n\n\nBoth hydration strategies perform transformation on the keys provided, so the keys \nof the array get translated from \nsnake_case\n to \ncammelCase\n, so if you provide an array like \n['username' => 'foo', 'first_name' => 'John']\n the Method strategy will attempt to use \nsetUsername\n and \nsetFirstName\n in order to hydrate the object; if the Property strategy is used it will look for \nusername\n and \nfirstName\n public properties on the object.\n\n\nBoth will preserve immutability of the hydrated object so you should keep that in mind",
            "title": "Hydration"
        },
        {
            "location": "/collections/",
            "text": "Introduction\n\n\nThere are 3 pretty generic collection classes that should provide at\nleast some benefit in a few scenarios.\n\n\nCollection\n\n\nThe base collection class is just an iterator and exposes 1 additional\nmethod \naddFilter\n which accepts a callback and passing it \n$value\n and \n$key\n\nin this order, under the hood it uses the built-in PHP \nCallbackFilterIterator\n to\nperform the filtering.\n\n\nCallbackCollection\n\n\nThis one is aimed at applying a callback to each element in the array\nmuch like \narray_map\n does, but instead of applying it instantly it is\nlazy and the callback is applied only when an item is retrieved\nfrom the iterator. The goal of that is to have as lazy as possible\ncollection. Which when working with large datasets will manipulate them\non the fly rather than in a single go.\n\n\nIt extends \nCollection\n so the filtering is still there, just note that\nthe callback is applied after the filtering so the filter function has\nto use the raw data.\n\n\nHydratableCollection\n\n\nThis one a thin wrapper around \nCallbackCollection\n to provide a simplified\nAPI to generate object specific collections. It takes a prototype instance\nthat implements \nHydratableInterface\n as it's 2nd argument in the constructor.\n\n\nJust note that the filtering will be applied \nafter\n the hydration since\nthe objects might have their own validation procedures in place and thus\nthe filtering could be \n$item->isVallid()\n instead of duplicating the logic\nevery you have to validate/filter the collection.",
            "title": "Collections"
        },
        {
            "location": "/collections/#introduction",
            "text": "There are 3 pretty generic collection classes that should provide at\nleast some benefit in a few scenarios.",
            "title": "Introduction"
        },
        {
            "location": "/collections/#collection",
            "text": "The base collection class is just an iterator and exposes 1 additional\nmethod  addFilter  which accepts a callback and passing it  $value  and  $key \nin this order, under the hood it uses the built-in PHP  CallbackFilterIterator  to\nperform the filtering.",
            "title": "Collection"
        },
        {
            "location": "/collections/#callbackcollection",
            "text": "This one is aimed at applying a callback to each element in the array\nmuch like  array_map  does, but instead of applying it instantly it is\nlazy and the callback is applied only when an item is retrieved\nfrom the iterator. The goal of that is to have as lazy as possible\ncollection. Which when working with large datasets will manipulate them\non the fly rather than in a single go.  It extends  Collection  so the filtering is still there, just note that\nthe callback is applied after the filtering so the filter function has\nto use the raw data.",
            "title": "CallbackCollection"
        },
        {
            "location": "/collections/#hydratablecollection",
            "text": "This one a thin wrapper around  CallbackCollection  to provide a simplified\nAPI to generate object specific collections. It takes a prototype instance\nthat implements  HydratableInterface  as it's 2nd argument in the constructor.  Just note that the filtering will be applied  after  the hydration since\nthe objects might have their own validation procedures in place and thus\nthe filtering could be  $item->isVallid()  instead of duplicating the logic\nevery you have to validate/filter the collection.",
            "title": "HydratableCollection"
        },
        {
            "location": "/rest/",
            "text": "Introduction\n\n\nAlthough there is nothing REST-specific in the core package, there\nis \nonion/rest\n that aims to allow more or less transparent conversion\nfrom entity to appropriate REST representation according to a given standard.\n\n\nBut in order to simplify the development and bring something along the\nlines of 'Controller' as in MVC-pattern there is the abstract class:\n\nOnion\\Framework\\Controller\\Controller\n it is a small pass through wrapper\naround your code that will do (request method) to (code method) translation\nand do some small handling to conform with the request methods. Like invoking\n\nget\n for \nHEAD\n requests if no designated method is present and remove the\nresponse body.",
            "title": "Rest"
        },
        {
            "location": "/rest/#introduction",
            "text": "Although there is nothing REST-specific in the core package, there\nis  onion/rest  that aims to allow more or less transparent conversion\nfrom entity to appropriate REST representation according to a given standard.  But in order to simplify the development and bring something along the\nlines of 'Controller' as in MVC-pattern there is the abstract class: Onion\\Framework\\Controller\\Controller  it is a small pass through wrapper\naround your code that will do (request method) to (code method) translation\nand do some small handling to conform with the request methods. Like invoking get  for  HEAD  requests if no designated method is present and remove the\nresponse body.",
            "title": "Introduction"
        },
        {
            "location": "/modules/",
            "text": "Introduction\n\n\nModules are a way to separate the application in order to preserve separation\nof code components and avoid your application to grow in to a monolith that\nis going to kill a kitten, destroy the world, make you insane and/or send\nyou to hell. So to allow this, the modules are designed to be separated\nbased on a route prefix. In order to achieve that.\n\n\nIn order to achieve that, You will probably need a localized routes defs\nthat will be loaded throughout the module and utilize the DelegateContainer\nto resolve the remaining dependencies.\n\n\nSetup\n\n\nIn this example we would assume you want to have a module that is handling\nthe \n/integrations\n prefix in your app. So first we will go through adding\nthe definition for a route to the global application:\n\n\nreturn [\n    [\n        'name' => 'integrations',\n        'pattern' => '/integrations',\n        'request_handler' => 'IntegrationsModule',\n        'class' => \\Onion\\Framework\\Router\\PrefixRoute::class,\n        'headers' => [\n            'Authorization' => true,\n        ]\n    ]\n];\n\n\n\n\nNote we've omitted the \nmiddleware\n key.\n\n\nThis will ensure that whenever we receive a request that starts with\n\n/integrations\n it will be sent to that request handler while also requiring\nthe client to provide an \nauthorization\n header for access, and register it\nin the container as \nIntegrationsModule\n. From there for the executed routes\nthe request will come as if there was never a prefix as it will get stripped\nto allow the applications to not have coupling to the routing they have.\nFor example, every route you define in the \nmodule\n must not contain the\nprefix or the routing will match only \n/integrations/integrations/...\n\nand we don't want to do that, right?\n\n\nWith that being said a factory for our imaginary module would look more\nor less like this:\n\n\n<?php\nnamespace App\\Module\\Integration;\n\n// imports...\n\nclass IntegrationModuleFactory implements FactoryInterface\n{\n    private getLocalContainer(): ContainerInterface\n    {\n        return new Container(compileConfigFiles(__DIR__ . '/../../config'));\n    }\n\n    public function build($delegateContainer)\n    {\n        // Note here we need to retrieve the main application\n        return $this->getLocalContainer()->get(Application::class);\n    }\n}\n\n\n\n\nAnd from here on the routing takes care of it and when the route matches\nin the parent application it will hand over the execution to the module\nand we are done. The middleware will stack between the application and\nmodule. Just when you are intentionally building a module, you might want\nto exclude an error handler in the modules in order to allow the application\nitself to handle the error handling, although that will depend entirely on\nyour design and components the possibilities are more or less limitless.",
            "title": "Modules"
        },
        {
            "location": "/modules/#introduction",
            "text": "Modules are a way to separate the application in order to preserve separation\nof code components and avoid your application to grow in to a monolith that\nis going to kill a kitten, destroy the world, make you insane and/or send\nyou to hell. So to allow this, the modules are designed to be separated\nbased on a route prefix. In order to achieve that.  In order to achieve that, You will probably need a localized routes defs\nthat will be loaded throughout the module and utilize the DelegateContainer\nto resolve the remaining dependencies.",
            "title": "Introduction"
        },
        {
            "location": "/modules/#setup",
            "text": "In this example we would assume you want to have a module that is handling\nthe  /integrations  prefix in your app. So first we will go through adding\nthe definition for a route to the global application:  return [\n    [\n        'name' => 'integrations',\n        'pattern' => '/integrations',\n        'request_handler' => 'IntegrationsModule',\n        'class' => \\Onion\\Framework\\Router\\PrefixRoute::class,\n        'headers' => [\n            'Authorization' => true,\n        ]\n    ]\n];  Note we've omitted the  middleware  key.  This will ensure that whenever we receive a request that starts with /integrations  it will be sent to that request handler while also requiring\nthe client to provide an  authorization  header for access, and register it\nin the container as  IntegrationsModule . From there for the executed routes\nthe request will come as if there was never a prefix as it will get stripped\nto allow the applications to not have coupling to the routing they have.\nFor example, every route you define in the  module  must not contain the\nprefix or the routing will match only  /integrations/integrations/... \nand we don't want to do that, right?  With that being said a factory for our imaginary module would look more\nor less like this:  <?php\nnamespace App\\Module\\Integration;\n\n// imports...\n\nclass IntegrationModuleFactory implements FactoryInterface\n{\n    private getLocalContainer(): ContainerInterface\n    {\n        return new Container(compileConfigFiles(__DIR__ . '/../../config'));\n    }\n\n    public function build($delegateContainer)\n    {\n        // Note here we need to retrieve the main application\n        return $this->getLocalContainer()->get(Application::class);\n    }\n}  And from here on the routing takes care of it and when the route matches\nin the parent application it will hand over the execution to the module\nand we are done. The middleware will stack between the application and\nmodule. Just when you are intentionally building a module, you might want\nto exclude an error handler in the modules in order to allow the application\nitself to handle the error handling, although that will depend entirely on\nyour design and components the possibilities are more or less limitless.",
            "title": "Setup"
        }
    ]
}